计数排序 算法
=========

算法概览
---------

**计数排序**算法 要解决的问题是要解决的问题是 排序问题，以下是排序问题的说明：

输入：n个数的一个序列<a1，a2，...，an>

输出：输入序列的一个排列<a1'，a2'，...，an'>，满足a1'<=a2'<=....<=an'。

排序是一个经典且有趣的问题，前几章讲的所有算法里，各元素的次序依赖于他们之间的比较，这类排序算法叫做**比较排序算法**，

根据决策树理论，任何比较算法都至少要经过nlgn次比较。因此我们说**比较排序算法是有下界的**。

计数排序、基数排序 和 桶排序 是三种线性时间复杂度算法，这几种算法的排序都不依赖元素之间的比较。

计数排序假设n个输入元素中的每一个元素都是0到整数k之间的整数，k为计数排序算法所能容纳元素的最大值。

对于待排序数组A中我们正在遍历的一个元素A[i]，如果它的值是j（0<=j<=k），我们可以直接把它放在排好序的数组B的B[j]位置上。然后把B中空元素去掉，B就是排好序的数组A。

算法性能
---------

最坏情况下时间复杂度：O(n)。

平均/期望的时间复杂度：O(n)。

算法伪代码
-----------

```
//A为待排序数组，B为空数组的引用（算法结束后，B将是A排好序的状态）,k为所能容纳元素的最大值。
COUNTING-SORT(A, B, k)
	构造一个新数组C，数组C下标从0开始，数组C有k个元素。并把这k个元素全初始化成0。
	for j = 1 to A.length
		C[A[j]] = C[A[j]] + 1
	for i = 1 to k
		C[i] = C[i]+C[i-1]
	for j = A[length] downto 1
		B[C[A[j]]] = A[j]
		C[A[j]] = C[A[j]] - 1
```