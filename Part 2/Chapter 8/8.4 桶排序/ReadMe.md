桶排序 算法
=======

算法概览
---------

**桶排序**算法 要解决的问题是要解决的问题是 排序问题，以下是排序问题的说明：

输入：n个数的一个序列<a1，a2，...，an>

输出：输入序列的一个排列<a1'，a2'，...，an'>，满足a1'<=a2'<=....<=an'。

桶排序假设待排序数组的数据服从均匀分布（均匀、独立的分布在[0，1)区间），均匀分布是一种很常见的分布方式。

如果待排序数组的值域不在[0，1)区间，而是某种比较大的整数，也可以把这些整数转存成某种小数，然后排序，排序之后再转回到原来的状态。

因为对输入的数据进行了假设，因此通常桶排序的效率很高。

桶排序算法将区间[0，1)划分为n个相同大小的子区间，这些子区间被称为**“桶”**，

因为输入数据是均匀，独立地分布在[0, 1)区间里的，所以一般不会出现很多元素都落在一个桶里的情况。

为了得到输出结果，我们先对每个桶中的数进行排序，然后遍历每个桶，按照次序把桶里的元素列出来即可。

算法性能
---------

最坏情况下时间复杂度：O(n^2)。

平均/期望的时间复杂度：O(n)。

算法伪代码
-----------

```
//在桶排序算法中，我们假设待排序数组是一个包含n个元素的数组A，且数组的每个元素满足A[i]在[0，1)区间。
//此外，算法还需要一个临时数组B[0..n-1]来存放链表（即桶），并假设存在一种这些链表的排序函数可以自动维护链表使其有序。
//如果不懂链表，可以使用数组和自定义的排序算法。
BUCKET-SORT(A)
	n = A.length
	创建一个新的数组B[0..n-1]
	for i = 0 to n - 1
		让所有B[i]都成为一个空链表
	for i= 1 to n
		//nA[i]向下取整
		把元素A[i]插入到B[nA[i]]中
	for i = 0 to n - 1
		把B[i]这个桶排序。
	遍历每个桶，按照次序把桶里的元素列出来
```