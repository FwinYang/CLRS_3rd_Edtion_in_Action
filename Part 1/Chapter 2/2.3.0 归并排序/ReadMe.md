归并排序
=====

适用问题的描述
----------------

**归并排序**算法 要解决的问题是排序问题，以下是排序问题的说明：

输入：n个数的一个序列<a1，a2，...，an>
输出：输入序列的一个排列<a1'，a2'，...，an'>，满足a1'<=a2'<=....<=an'。

算法性能
---------

最坏情况下时间复杂度：O(nlgn)。

平均/期望的时间复杂度：O(nlgn)。

**注-算法导论中的lg指以2为底，n的对数，而不是我们通常想象的以10为底。**

书中提出这个算法的教学目的
-----------------------------
归并排序是一种经典的排序算法，其时间复杂度与同样有名的堆排序相当，在一些情况下这个算法的效率比甚至比快速排序更好。

归并排序算法也是分治思想下产生算法的典型例子，它通过把排序这个问题递归地拆分成“合并两个已排序数组”的问题来简化计算过程，如果它发现自己处理的数组是无序的，它只需要把不断把数组拆分，直到拆成多个单一元素（一定有序）的数组。

然后对于每一个数组，它都和隔壁数组配对：

他们分别拿出自己最小的元素对比，更小的放在前面，不那么小的放在后面。然后再拿出自己第二小的元素互相对比...直到合并成一个数组。

因此这个算法叫做归并算法，这种分治和归并的思路可以高效地很多问题，比如Leetcode每周活动里的["两个人通过各自的就餐点清单找出最佳公共清单"](https://leetcode.com/problems/minimum-index-sum-of-two-lists/#/description)问题。

书中还藉由这个算法和插入排序算法对比，讲解了如果分析和设计基础的分治算法。

算法伪代码
-----------

**代码片段1：**

```
//这段代码展示的是归并排序算法中的“合并两个已经排序的子数组”这一过程，而非归并排序的全部。
//归并排序通过把待排序数组拆成多个单一元素（一定有序）的数组，再不断地归并这些数组（不断地使用这个过程）来实现排序。
//待排序的数组为A，p、q和r为A的数组下标，p、q、r之间满足p<=q<r，这个过程假定子数组A[p..q]和A[q+1..r]是已经排好序的。
//这个过程合并这两个单一子数组，形成一个排好序的单一子数组代替原先的无序数组A[p..r]。
//∞是这个算法中特殊的标记符号，为了防止每次都检查分裂出来的单个数组是否为空，每一个数组最后都添加这个（值无穷大的）元素作为特殊标记，当相邻的两个数组都只剩下这个元素的时候，他们就已经完成归并。在cpp中现代的实现方式中，我们避免了这种难以理解的标记方式。

MERGE(A,q,p,r)
	n1 = q-p+1
	n2 = r-q
	两个有序新数组就是L[1..n1+1]和R[1..n2+1]。
	//上句话是想说明数组L有n1+1个元素，数组R有n2+1个元素。
	for i=1 to n1
		L[i] = A[p+i-1]
		//上句话表面数组L的值被初始化为数组A[p..q]
	for j=1 to n2
		R[j] = A[q+j]
		//上句话表面数组R的值被初始化为数组A[q+1..r]
	L[n1+1] = ∞
	R[n2=1] = ∞
	//上两句话是说在这两个数组的尾部都放上∞这个标记
	i = j = 1
	//以下伪代码是说从A[p]到A[q]（这个临时数组的头和尾）开始，重写A的元素值。
	//L和R是已经被排好序的数组，它们被从头到尾哪个比较小检视，哪个比较小，先用哪个的元素给A赋值
	for k = p to r
		if L[i]<=R[j]
			A[k] = L[i]
			i = i+1
		else 
			A[k]=R[j]
			j = j+1
```

**代码片段2：**

```
//这段代码展示的是整个归并排序算法函数，这个函数通过调用上面的MERGE函数进行递归的归并排序

MERGE-SORT(A,p,r)
	if(p < r)
		//下面的(p+r)/2表达式向下取整
		q = ⌊ (p+r)/2⌋
		MERGE-SORT(A,p,q)
		MERGE-SORT(A,q+1,r)
		MERGE(A,p,q,r)
```