矩阵的Strassen算法
===============

适用问题的描述
----------------

**矩阵的Strassen**算法 要解决的问题是一种特定的问题，这种算法可以用来计算两个矩阵A和B相乘，

A和B的行数和列数都必须一致，且这个数是2的n次幂，n为正整数。

算法性能
---------

最坏情况下时间复杂度：O(n^lg7)。

平均/期望的时间复杂度：O(n^lg7)。

书中提出这个算法的教学目的
-----------------------------

根据矩阵的数学定义，要通过三层循环求解两个矩阵的乘积，因此从数学定义上得到的矩阵相乘算法复杂度理论上应该是O(n^3)，

以前很多人都认为这个算法是无法被优化的。不过德国人Strassen针对行列数为n^2的方阵进行研究，得出了一种更为简单的矩阵相乘计算方法，

这种方法的时间复杂度为O(n^lg7)，lg7在2.8~2.81之间，因此这个算法是比O(n^3)的普通实现方法更好的一种使用分治思想的算法。

算法伪代码
-----------

```
//《算法导论（第三版）》把写出这个算法的伪代码作为课后题来让学生思考，并没有提供Strassen算法的伪代码
//这里我们简单的用文字描述这个算法。

这个算法中，对于每一个行数列数均为n的矩阵A和B的乘法，把矩阵A和B分成行数列数均为四个n/2的子矩阵，
预先准备一个代表矩阵A和B乘积的空白矩阵C（C的大小也为n*n）。

我们假定对于一个行数列数均为n的矩阵X，
X11代表包含X的0~n/2-1行和0~n/2-1列中交叉的元素的新矩阵，
X12代表包含X的0~n/2-1行和n/2~n列中交叉的元素的新矩阵，
X21代表包含X的n/2~n行和0~n/2-1列中交叉的元素的新矩阵，
X22代表包含X的n/2~n行和n/2~n列中交叉的元素的新矩阵。

把A分成A11，A12，A21，A22四个部分。
把B分成B11，B12，B21，B22四个部分。
把C分成C11，C12，C21，C22四个部分。

现在定义7个新矩阵。
M1 = (A11+A22)(B11+B22)
M2 = (A21+A22)B11
M3 = A11(B12-B22)
M4 = A22(B21-B11)
M5 = (A11+A12)B22
M6 = (A21 - A11)(B11 + B12)
M7 = (A12-A22)(B21+B22)

作为A和B乘积的结果矩阵C可以通过组合上述7个新矩阵之后得到
C11 = M1+M4-M5+M7
C12 = M3+M5
C21 = M2+M4
C22 = M1-M2+M3+M6

Strassen算法把几个行列数为n的矩阵乘法递归地转换为几个行列数为n/2的矩阵之间的乘法和加法等运算。
当递归出的新矩阵A和B足够小的时候，再用普通的乘法解出它们的积。
这个积将会被代入到之前的M1~7七个矩阵中进行计算。

```