散列表函数
=======

适用问题的描述
----------------

**散列表函数算法** 要解决的问题是一类特定的问题，它在**链接法**散列策略下追求**散列函数**的有效性，

散列函数要做的操作是：对于一个带有关键字k的元素，如果我们想要把这个元素加入散列表以方便索引，可以先把这个关键字通过散列函数h(k)的计算得出的结果x，

再把这个元素放在散列表第x个位置上，对于一个k值，h(k)函数计算出的结果是固定的。

好的散列函数会让相近关键字分配到同一个槽中的可能性尽可能变小。

本小节描述了三种散列表函数。分别是**除法散列法**，**乘法散列法** 和 **全域散列法** 这三种思想下构造的散列函数，这三种散列函数都通过链接法的思想处理冲突，

其中全域散列法是一类满足用全域函数对关键字进行散列的方法的统称，它比其他两种方法更追求相似值的不冲突分配。

对于关键字不是正整数形式的元素集合，我们通常地把关键字通过某种方式（比如编码表）转换成一个唯一的正整数，再交给散列函数进行散列。

本小节的实现中我们将实现这三种方法。

算法性能
---------

最坏情况下时间复杂度：O(1)。

平均/期望的时间复杂度：O(1)。

书中提出这个算法的教学目的
-----------------------------

**除法散列法**

在除法散列法中，通过取k（关键字）除以m（散列函数的总槽数）以后的余数，即散列函数为：

`h(k) = kmodm`

不过在应用除法散列法的时候，要避免使用某些值，比如m不应该为2的正整数幂。

**乘法散列法**

构造散列函数的乘法散列法包含两个步骤，

第一步，用关键字k乘上常数A，A通常为0.6180339887，提取kA的小数部分，

第二步，用m（总槽数）乘以这个值，再向下取整。总之，散列函数为：

`h(k) = m(kAmod1)`

**全域散列法**

全域散列法不是一个方法的简称，而是对一类方法的简称。

它对于不同次处理的关键字随机地选择散列函数，这组特定的散列函数H将给定的关键字全域U散列到{0， 1， ... ，m-1}中。

如果从H中随机地选择一个散列函数，发生关键字冲突的概率最大为1/m。

首先，选择一个足够大的素数p，使得关键字的全域k被p包含，设集合Zp为{0，1，...，p-1}，

Zp*为{1，2，...，p-1}，对于任意属于Zp*的a，和任意属于Zp的b，定义散列函数h(a,b) = ((ak+b)modp)modm。

例如，如果有p = 17，m = 6，则有h(3,4)(8) = 5。

这里的H就由a，b各种取值情况的h组成。这种散列函数叫做全域散列。