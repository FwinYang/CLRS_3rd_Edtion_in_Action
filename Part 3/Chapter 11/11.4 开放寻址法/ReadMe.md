开放寻址法
=======

适用问题的描述
----------------

**开放寻址算法** （Open Adderssing）是一种有别于链接法的散列策略，

这种策略把所有的元素都通过散列函数存储在散列表本身中，因此散列表的容量要大于或等于待存储的元素数量（装载因子α不超过1）。

当查找某个元素时，再使用探查函数系统地检查每个表项直到找到查找的元素（或遍历散列表也找不到目标元素）。

比起链接法开放寻址法的好处在于不用存储一些指针，而是计算出要存取的槽序列，节省了一些空间，这样就潜在地减少了冲突数，提高了检索速度。

散列函数h根据其输入的关键字k和探查号（0~m-1，这些是槽的序号），找出合适的槽，

这样，散列函数h就变为：`U×{0,1,...,m-1}->{0,1,...,m-1}`。

对于每一个关键字k，其探查序列为：`{h(k,0), h(k,1), ..., h(k,m-1)}`。

本小节的实现中我们将给出通用的开放寻址法插入和查找操作的伪代码，以及三种常用的探查函数h。

算法性能
---------

最坏情况下时间复杂度：O(1)。

平均/期望的时间复杂度：O(1)。

算法概览
---------

关键字为k，散列表为T

通用的开放寻址法下的插入算法伪代码：

```
HASH-INSERT(T,k)
	i = 0
	repeat
		j = h(k,i)
		if T[j] == NIL
			T[j] = k
			return j
		else i = i + 1
	until i == m
	error "hash table overflow"
```
	
通用的开放寻址法下的查询算法伪代码：

```
HASH-SEARCH(T,k)
	i = 0
	repeat
		j = h(k,i)
		if T[j] == k
			return j
		i = i + 1
	until T[j] == NIL or i==m
	return NIL
```

线性探查

`h(k,i) = (h'(k)+i)mod m, i = 0,1, ... , m-1`

二次探查

`h(k,i) = (h'(k)+c1i+c2i^2)mod m, i = 0,1, ... , m-1`

双重散列

`h(k,i) = (h1(k)+ih2(k))mod m, i = 0,1, ... , m-1`