开放寻址法
=======

算法概览
---------

**开放寻址算法** （Open Adderssing）是一种有别于链接法的散列策略，

这种策略把所有的元素都通过散列函数存储在散列表本身中，因此散列表的容量要大于或等于待存储的元素数量（装载因子α不超过1）。

当查找某个元素时，再使用探查函数系统地检查每个表项直到找到查找的元素（或遍历散列表也找不到目标元素）。

比起链接法开放寻址法的好处在于不用存储一些指针，而是计算出要存取的槽序列，节省了一些空间，这样就潜在地减少了冲突数，提高了检索速度。

散列函数h根据其输入的关键字k和探查号（0~m-1，这些是槽的序号），找出合适的槽，

这样，散列函数h就变为：`U×{0,1,...,m-1}->{0,1,...,m-1}`。

对于每一个关键字k，其探查序列为：`{h(k,0), h(k,1), ..., h(k,m-1)}`。

本小节的实现中我们将给出通用的开放寻址法插入和查找操作的伪代码，以及三种常用的探查函数h。

算法性能
---------

最坏情况下时间复杂度：O(m)。

平均/期望的时间复杂度：O(1)。

算法伪代码
-----------

关键字为k，散列表为T。

通用的开放寻址法下的**插入算法**伪代码：

```
HASH-INSERT(T,k)
	i = 0
	repeat
		j = h(k,i)
		if T[j] == NIL
			T[j] = k
			return j
		else i = i + 1
	until i == m
	error "hash table overflow"
```
	
通用的开放寻址法下的**查询算法**伪代码：

```
HASH-SEARCH(T,k)
	i = 0
	repeat
		j = h(k,i)
		if T[j] == k
			return j
		i = i + 1
	until T[j] == NIL or i==m
	return NIL
```

线性探查

`h(k,i) = (h'(k)+i)mod m, i = 0,1, ... , m-1`

h'为一个普通的辅助散列函数U->(0,1,...,m-1)。

二次探查

`h(k,i) = (h'(k)+c1i+c2i^2)mod m, i = 0,1, ... , m-1`

其中c1，c2为正的辅助常数。设置更合理的辅助常数可以让散列函数的性能更好。

双重散列

`h(k,i) = (h1(k)+ih2(k))mod m, i = 0,1, ... , m-1`

这里为了让函数的值域覆盖整个散列表（使散列表没有空缺的部分），h2(k)的值必须一直和表大小m互素（互质）。
有一种简便的方法确保这个条件成立，那就是取m为2的幂数，并设计一个只产生奇数的函数h2。这是利用“奇数和2的所有次幂都互质”这个性质。
另一种简便的方式是把m设为一个素数，然后设计一个总是返回一个比m小的正整数值的函数h2。
比如：`h1(k) = k mod m, h2(k) = 1+(k mod m')`，m'可以是比m略小的值，比如m-1。