前序/中序/后序遍历 算法
===============

算法概览
---------

**先序/中序/后序遍历**算法（简称三序遍历） 是基于**二叉树**的操作，在之前的10.4小节我们已经掌握了有根树的概念及其表示，

二叉树可以看成是一种有根树的特例：即一种每个节点的子节点只有0~2个的有根树，这很好理解。

本章的**二叉搜索树**又是二叉树的一种特例，**对于一个二叉树的任意节点x，其左子树的关键字最大不超过x的关键字，并且其右子树的关键字最小不低于x的关键字，那么这个二叉树就被称为二叉搜索树**（因为这种结构适合字典操作）。

二叉搜索树支持搜索、求树中关键字最小的元素、求关键字最大的元素、插入元素、删除元素、求一个子节点的前驱/后继（接下来的章节会详细讨论这些概念）等操作，

这些操作都要使二叉搜索树在操作后仍满足二叉搜索树的性质，不破坏节点的结构和关系。

遍历树也是其中的一种基本操作（而且不仅适用于二叉搜索树，对所有二叉树，先/中/后序的遍历的意义和实际操作都是一样的）。

**在编程中，遍历通常是指按一定的顺序访问一种结构中的所有元素**。遍历二叉树就是把树中所有节点都访问（通常的做法是打印这个节点关键字的值表示“访问”）一遍。

正如之前的文字说明的，遍历一个二叉树有三种常用的方法，它们的唯一区别只是访问树中元素的顺序不同。

**先序遍历**是指，从二叉树的根节点开始，对于每一个有子节点的节点：
1. 先访问它的根节点。
2. 再对它的左子节点进行前序遍历。
3. 最后对它的右子节点进行前序遍历。
并且对于每一个叶子结点：直接访问它本身。

**中序遍历和后序遍历的情况类似先序遍历**，只是调换每次递归时访问的顺序，我们在代码里给出了它们的实现。

本章先不考虑怎么从一个序列或一组数字中构建一个二叉搜索树，重点在遍历算法上，因此我们先假设已经存在一个可以被我们遍历的非空二叉搜索树结构。

在代码实现中，这种二叉树结构的实现方式非常类似于10.4小节中描述的有根树的实现方式，读过那章的人就很容易理解这种表示法。

算法性能
---------

时间复杂度：O(n)。

算法伪代码（仅给出中序遍历的伪代码，其他遍历方法类似中序遍历）
----------------------------------------------------------------------

```
INORDER-TREE-WALK(x)
	if x != NIL
		INORDER-TREE-WALK(x.left)
		print x.key
		INORDER-TREE-WALK(x.right)
```